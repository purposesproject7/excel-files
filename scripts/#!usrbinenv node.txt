#!/usr/bin/env node
/**
 * Student Review Updater - PRODUCTION VERSION
 * Maps Excel component names to exact Schema component names
 */

const XLSX = require('xlsx');
const axios = require('axios');
const fs = require('fs');
const readline = require('readline');

const EXCEL_FILE_PATH = '/home/administrator/Desktop/excel-files/Upload/student_mark_assign.xlsx';
const API_BASE_URL = 'http://localhost:5000/api/student';
const AUTH_TOKEN = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY4Zjg5N2JlMjJiN2QwODQ3NDRmNjU0OCIsImVtYWlsSWQiOiJhZG1pbkB2aXQuYWMuaW4iLCJlbXBsb3llZUlkIjoiQURNSU4wMDEiLCJyb2xlIjoiYWRtaW4iLCJpYXQiOjE3NjE2NzcwOTMsImV4cCI6MTc2MTc2MzQ5M30.8gftdd6WoUdWw0l8Gho61KDzqlI7hQJQ4rOZ5o6mZGc';

class StudentReviewUpdater {
    constructor(excelFilePath, apiBaseUrl, authToken, mode = 'dry') {
        this.excelFilePath = excelFilePath;
        this.apiBaseUrl = apiBaseUrl;
        this.authToken = authToken;
        this.mode = mode;

        // ‚úÖ Component mapping with EXACT schema component names
        this.componentMapping = {
            'MCA': {
                'draftReview': {
                    excelPrefix: 'Zero-th Review',
                    components: {
                        'Problem Formulation': 'Problem Formulation' // Maps to itself
                    },
                    isDummy: true
                },
                'guideReview1': {
                    excelPrefix: 'Review 1',
                    components: {
                        'Literature Review & Design of Methodology': 'Literature Review & Design of Methodology'
                    },
                    isDummy: true
                },
                'guideReview2': {
                    excelPrefix: 'Dummy',
                    components: {
                        'test': 'test'
                    },
                    isDummy: true
                },
                'review0': {
                    excelPrefix: 'Review 2',
                    components: {
                        // Excel name -> Schema name mapping
                        'Proposed Model / Architecture / Framework Designed': 'Proposed Model/ Architecture/Framework Designed',
                        'Modules Description': 'Modules Description',
                        'Detailed design with Explanations (Algorithms)': 'Detailed Design with explanation(Algorithms)',
                        'Partial Implementation (60%)/Dataset description / Results Obtained': 'Partial Implementation(60%) /Dataset Description/\tResults obtained',
                        'Presentation & Ability to Answer questions': 'Presentation, and Ability to answer questions'
                    },
                    isDummy: false
                }
            },
            'BTech': {
                'draftReview': {
                    excelPrefix: 'Zero-th Review',
                    components: {
                        'Title & Problem Statement': 'Title  & Problem statement'
                    },
                    isDummy: true
                },
                'panelReview1': {
                    excelPrefix: 'Review 1',
                    components: {
                        'Problem Statement & Motivation': 'Knowledge on Research Domain/Problem statement',
                        'Literature Review & Gap Identification': 'Literature Review (15 Latest Papers ‚Äì Minimum - from Reputed Journals/ Conferences)',
                        'Objective & Scope': 'Design of the proposed methodology',
                        'Proposed methodology & Feasability': 'Implementation',
                        'Presentation & Communication': 'Presentation, and Ability to answer questions'
                    },
                    isDummy: false
                },
                'guideReview1': {
                    excelPrefix: 'Dummy ',
                    components: {
                        'test': 'test'
                    },
                    isDummy: true
                }
            },
            'M.Tech 2yr (MCS,MCB,MAI)': {
                'draftReview': {
                    excelPrefix: 'Dummy',
                    components: {
                        'test': 'test'
                    },
                    isDummy: true
                },
                'panelReview1': {
                    excelPrefix: '2nd Review',
                    components: {
                        'Explanation of all the modules one by one which includes the algorithm(s)': 'Explanation of all the modules 1 by 1 which includes Algorithm',
                        '70% implementation with results': '70% implementation with results',
                        'Presentation skill and ability to answer questions': 'Presentation Skills and Ability to answer Questions'
                    },
                    isDummy: false
                }
            }
        };

        this.failedUpdates = [];
        this.successfulUpdates = [];
        this.totalStudentsProcessed = 0;
        this.totalReviewsSkipped = 0;
        this.logFile = `update_log_${new Date().toISOString().replace(/[:.]/g, '-')}.log`;
    }

    log(message, level = 'INFO') {
        const timestamp = new Date().toISOString();
        const logMessage = `${timestamp} - ${level} - ${message}`;
        console.log(logMessage);
        fs.appendFileSync(this.logFile, logMessage + '\n');
    }

    loadExcelData() {
        try {
            this.log(`Loading Excel file: ${this.excelFilePath}`);
            const workbook = XLSX.readFile(this.excelFilePath);
            this.sheetData = {};

            this.log('\nüîç Detected sheet names:');
            workbook.SheetNames.forEach((name, i) => {
                this.log(`  ${i + 1}. "${name}"`);
            });

            for (const sheetName of workbook.SheetNames) {
                const worksheet = workbook.Sheets[sheetName];
                const jsonData = XLSX.utils.sheet_to_json(worksheet);
                this.sheetData[sheetName] = jsonData;
                this.log(`‚úÖ Loaded sheet '${sheetName}' with ${jsonData.length} students`);
            }

            return true;
        } catch (error) {
            this.log(`‚ùå Failed to load Excel file: ${error.message}`, 'ERROR');
            return false;
        }
    }

    getDepartmentFromSheetName(sheetName) {
        if (sheetName.includes('MCA')) return 'MCA';
        if (sheetName.includes('BTech')) return 'BTech';
        if (sheetName.includes('M.Tech')) return 'M.Tech 2yr (MCS,MCB,MAI)';
        return null;
    }

    extractComponentMarks(row, reviewConfig, excelPrefix) {
        const componentMarks = {};

        // ‚úÖ NEW: Map Excel names to Schema names
        for (const [excelName, schemaName] of Object.entries(reviewConfig.components)) {
            const colName = `${excelPrefix}_${excelName}`;

            if (row[colName] !== undefined && row[colName] !== null && row[colName] !== '') {
                const mark = parseFloat(row[colName]);
                if (!isNaN(mark)) {
                    // Store with SCHEMA name, not Excel name
                    componentMarks[schemaName] = mark;
                    this.log(`    ‚úÖ Mapped: "${excelName}" -> "${schemaName}" = ${mark}`);
                } else {
                    this.log(`  ‚ö†Ô∏è  Invalid mark for '${colName}': ${row[colName]}`, 'WARN');
                }
            }
        }

        return componentMarks;
    }

    getDepartmentForRow(row, sheetName) {
        if (sheetName.includes('M.Tech') && row['Department']) {
            const deptVal = String(row['Department']).trim();
            if (deptVal && deptVal !== 'undefined') {
                return deptVal;
            }
        }
        return this.getDepartmentFromSheetName(sheetName);
    }

    processStudentRow(row, department) {
        try {
            const regNo = String(row['Register No'] || '').trim();
            const studentName = String(row['Name'] || '').trim();

            if (!regNo || regNo === 'undefined' || regNo === '') {
                this.log(`‚ö†Ô∏è  Skipping row: No valid registration number`, 'WARN');
                return null;
            }

            this.log(`\nüìù Processing: ${studentName} (${regNo}) - Dept: ${department}`);

            const patDetected = row['PAT_Detected'] &&
                String(row['PAT_Detected']).toLowerCase() === 'yes';

            const deptMapping = this.componentMapping[department];
            if (!deptMapping) {
                this.log(`‚ùå No mapping found for department: ${department}`, 'ERROR');
                return null;
            }

            const marksUpdate = [];

            for (const [reviewName, reviewConfig] of Object.entries(deptMapping)) {
                if (reviewConfig.isDummy) {
                    this.log(`  ‚è≠Ô∏è  Skipping dummy review: ${reviewName}`);
                    this.totalReviewsSkipped++;
                    continue;
                }

                const excelPrefix = reviewConfig.excelPrefix;
                this.log(`  üìã Processing ${reviewName} (${excelPrefix}):`);
                
                const componentMarks = this.extractComponentMarks(row, reviewConfig, excelPrefix);

                if (Object.keys(componentMarks).length === 0) {
                    this.log(`  ‚ÑπÔ∏è  No marks found for ${reviewName}`);
                    continue;
                }

                const commentsCol = `${excelPrefix}_Comments`;
                const attendanceCol = `${excelPrefix}_Attendance`;

                const comments = row[commentsCol] ? String(row[commentsCol]).trim() : '';
                const attendancePresent = row[attendanceCol] &&
                    String(row[attendanceCol]).toLowerCase() === 'present';

                marksUpdate.push({
                    reviewName: reviewName,
                    marks: componentMarks,
                    comments: comments,
                    attendance: {
                        value: attendancePresent,
                        locked: false
                    },
                    locked: false
                });

                const marksSum = Object.values(componentMarks).reduce((a, b) => a + b, 0);
                const status = attendancePresent ? 'Present' : 'Absent';
                
                this.log(`  ‚úÖ ${reviewName}: ${Object.keys(componentMarks).length} components, Total: ${marksSum}, Status: ${status}`);
            }

            if (marksUpdate.length === 0) {
                this.log(`  ‚ö†Ô∏è  No valid reviews with marks for ${studentName}`);
                return null;
            }

            return {
                regNo: regNo,
                name: studentName,
                payload: {
                    marksUpdate: marksUpdate,
                    PAT: patDetected
                }
            };
        } catch (error) {
            this.log(`‚ùå Error processing student: ${error.message}`, 'ERROR');
            this.log(`   Stack: ${error.stack}`, 'ERROR');
            return null;
        }
    }

    async sendStudentUpdate(regNo, payload) {
        const url = `${this.apiBaseUrl}/${regNo}`;

        if (this.mode === 'dry') {
            this.log(`\n[DRY RUN] Would send to: ${url}`);
            this.log(`[DRY RUN] Payload:\n${JSON.stringify(payload, null, 2)}`);
            return { success: true, data: { message: 'Dry run - no actual API call' } };
        }

        try {
            this.log(`\nüì§ Sending PUT request to: ${url}`);
            this.log(`üì¶ Payload:\n${JSON.stringify(payload, null, 2)}`);

            const response = await axios.put(url, payload, {
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.authToken}`
                },
                timeout: 30000
            });

            this.log(`‚úÖ Response: ${response.status} ${response.statusText}`);
            this.log(`üì• Updated fields: ${JSON.stringify(response.data.updatedFields, null, 2)}`);

            return { success: true, data: response.data };
        } catch (error) {
            let errorMsg;
            if (error.response) {
                errorMsg = `HTTP ${error.response.status}: ${JSON.stringify(error.response.data, null, 2)}`;
            } else {
                errorMsg = `Request failed: ${error.message}`;
            }
            
            this.log(`‚ùå Error: ${errorMsg}`, 'ERROR');
            return { success: false, error: errorMsg };
        }
    }

    async processSheet(sheetName, data) {
        const baseDepartment = this.getDepartmentFromSheetName(sheetName);

        if (!baseDepartment) {
            this.log(`‚ö†Ô∏è  Unknown sheet: ${sheetName}, skipping`, 'WARN');
            return 0;
        }

        this.log(`\n${'='.repeat(80)}`);
        this.log(`üìã Processing Sheet: ${sheetName}`);
        this.log(`üè´ Base Department: ${baseDepartment}`);
        this.log(`üë• Total Students: ${data.length}`);
        
        if (this.mode === 'test') {
            this.log(`üß™ TEST MODE: Will process only 1 student`);
        }
        
        this.log('='.repeat(80));

        let processedCount = 0;

        for (let i = 0; i < data.length; i++) {
            const row = data[i];
            
            try {
                const department = this.getDepartmentForRow(row, sheetName) || baseDepartment;
                const studentData = this.processStudentRow(row, department);

                if (studentData) {
                    const { regNo, name, payload } = studentData;
                    const result = await this.sendStudentUpdate(regNo, payload);

                    if (result.success) {
                        this.log(`\n‚úÖ SUCCESS: Updated ${name} (${regNo})`);
                        this.successfulUpdates.push({
                            sheet: sheetName,
                            reg_no: regNo,
                            name: name,
                            reviews_count: payload.marksUpdate.length
                        });
                        processedCount++;
                    } else {
                        this.log(`\n‚ùå FAILED: ${name} (${regNo})`, 'ERROR');
                        this.failedUpdates.push({
                            sheet: sheetName,
                            reg_no: regNo,
                            name: name,
                            error: result.error
                        });
                    }

                    if (this.mode === 'test' && processedCount >= 1) {
                        this.log(`\nüß™ TEST MODE: Stopping after 1 student`);
                        break;
                    }

                    if (this.mode === 'live') {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }
            } catch (error) {
                const regNo = row['Register No'] || 'Unknown';
                const name = row['Name'] || 'Unknown';
                this.log(`\n‚ùå Exception for ${name} (${regNo}): ${error.message}`, 'ERROR');
                this.failedUpdates.push({
                    sheet: sheetName,
                    reg_no: regNo,
                    name: name,
                    error: error.message
                });
            }
        }

        this.log(`\n‚úÖ Sheet '${sheetName}' complete: ${processedCount} students processed`);
        return processedCount;
    }

    async processAllSheets() {
        if (!this.loadExcelData()) {
            return false;
        }

        this.totalStudentsProcessed = 0;

        for (const [sheetName, data] of Object.entries(this.sheetData)) {
            const processed = await this.processSheet(sheetName, data);
            this.totalStudentsProcessed += processed;
            
            if (this.mode === 'test' && processed > 0) {
                this.log(`\nüß™ TEST MODE: Stopping after first sheet`);
                break;
            }
        }

        this.log(`\n${'='.repeat(80)}`);
        this.log('üéâ PROCESSING COMPLETE');
        this.log('='.repeat(80));
        this.log(`‚úÖ Total Students: ${this.totalStudentsProcessed}`);
        this.log(`‚úÖ Successful: ${this.successfulUpdates.length}`);
        this.log(`‚ùå Failed: ${this.failedUpdates.length}`);
        this.log(`‚è≠Ô∏è  Dummy Reviews Skipped: ${this.totalReviewsSkipped}`);

        return true;
    }

    generateReport() {
        const report = {
            timestamp: new Date().toISOString(),
            mode: this.mode,
            summary: {
                total_students_processed: this.totalStudentsProcessed,
                total_successful: this.successfulUpdates.length,
                total_failed: this.failedUpdates.length,
                total_reviews_skipped: this.totalReviewsSkipped
            },
            successful_updates: this.successfulUpdates,
            failed_updates: this.failedUpdates
        };

        const reportFilename = `update_report_${this.mode}_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
        fs.writeFileSync(reportFilename, JSON.stringify(report, null, 2));

        console.log('\n' + '='.repeat(80));
        console.log('üìä FINAL SUMMARY');
        console.log('='.repeat(80));
        console.log(`Mode: ${this.mode.toUpperCase()}`);
        console.log(`‚úÖ Processed: ${report.summary.total_students_processed}`);
        console.log(`‚úÖ Successful: ${report.summary.total_successful}`);
        console.log(`‚ùå Failed: ${report.summary.total_failed}`);
        console.log(`‚è≠Ô∏è  Skipped: ${report.summary.total_reviews_skipped}`);

        if (this.failedUpdates.length > 0) {
            console.log('\n‚ùå FAILED UPDATES:');
            this.failedUpdates.slice(0, 10).forEach((f, i) => {
                console.log(`${i + 1}. ${f.name} (${f.reg_no})`);
            });
        }

        console.log('='.repeat(80));
        console.log(`\nüìÑ Log: ${this.logFile}`);
        console.log(`üìÑ Report: ${reportFilename}`);

        return report;
    }
}

function askQuestion(query) {
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    return new Promise(resolve => rl.question(query, answer => {
        rl.close();
        resolve(answer);
    }));
}

async function main() {
    console.log('\n' + '='.repeat(80));
    console.log('üöÄ STUDENT REVIEW UPDATER - SCHEMA-MAPPED VERSION');
    console.log('='.repeat(80));
    console.log('‚úì Maps Excel names to exact Schema component names');
    console.log('‚úì No duplicate components - clean updates');
    console.log('='.repeat(80));

    if (!fs.existsSync(EXCEL_FILE_PATH)) {
        console.log(`\n‚ùå File not found: ${EXCEL_FILE_PATH}`);
        process.exit(1);
    }

    console.log(`\nüìÅ Excel: ${EXCEL_FILE_PATH}`);
    console.log(`üåê API: ${API_BASE_URL}/:regNo`);
    
    console.log('\n' + '-'.repeat(80));
    console.log('SELECT MODE:');
    console.log('  1. DRY RUN - Validate & show mappings');
    console.log('  2. TEST - Update 1 student');
    console.log('  3. LIVE - Update ALL students');
    console.log('-'.repeat(80));

    const modeChoice = await askQuestion('\nSelect (1/2/3): ');
    
    let mode;
    switch(modeChoice.trim()) {
        case '1': mode = 'dry'; break;
        case '2': mode = 'test'; break;
        case '3': mode = 'live'; break;
        default:
            console.log('‚ùå Invalid choice');
            process.exit(1);
    }

    if (mode === 'test' || mode === 'live') {
        const confirm = await askQuestion(`\nType 'CONFIRM': `);
        if (confirm.trim() !== 'CONFIRM') {
            console.log('‚ùå Cancelled');
            process.exit(0);
        }
    }

    const updater = new StudentReviewUpdater(EXCEL_FILE_PATH, API_BASE_URL, AUTH_TOKEN, mode);

    console.log('\nüîÑ Starting...\n');
    await updater.processAllSheets();
    updater.generateReport();
    
    console.log('\n‚úÖ Complete!\n');
}

if (require.main === module) {
    main().catch(error => {
        console.error('\n‚ùå Fatal error:', error);
        process.exit(1);
    });
}

module.exports = StudentReviewUpdater;
